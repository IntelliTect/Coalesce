import{_ as n,c as l,I as s,a7 as o,l as e,a as t,D as r,o as i}from"./chunks/framework.BkavzUpE.js";const _=JSON.parse('{"title":"[Search]","description":"","frontmatter":{},"headers":[],"relativePath":"modeling/model-components/attributes/search.md","filePath":"modeling/model-components/attributes/search.md"}'),c={name:"modeling/model-components/attributes/search.md"},p=o("",26),h=e("p",null,[t("If set to true (the default), each word in the search terms will be searched for in each searchable field independently, and a row will only be considered a match if each word in the search term is a match on at least one searchable property where "),e("code",null,"IsSplitOnSpaces == true")],-1),d=e("p",null,[t("This is useful when searching for a full name across two or more fields. In the above example, using "),e("code",null,"IsSplitOnSpaces = true"),t(" would provide more intuitive behavior since it will search both first name and last name for each word entered into the search field. But, "),e("a",{href:"https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/",target:"_blank",rel:"noreferrer"},"you probably shouldn't be doing that"),t(".")],-1),u=o("",2),D=e("p",null,"A comma-delimited list of model class names that, if set, will prevent the targeted property from being searched unless the root object of the API call was one of the specified class names.",-1),m=e("p",null,"A comma-delimited list of model class names that, if set, will prevent the targeted property from being searched if the root object of the API call was one of the specified class names.",-1);function y(b,f,g,w,C,v){const a=r("Prop");return i(),l("div",null,[p,s(a,{def:"public bool IsSplitOnSpaces { get; set; } = true;"}),h,d,s(a,{def:"public SearchMethods SearchMethod { get; set; } = SearchMethods.BeginsWith;"}),u,s(a,{def:"public string RootWhitelist { get; set; } = null;"}),D,s(a,{def:"public string RootBlacklist { get; set; } = null;"}),m])}const k=n(c,[["render",y]]);export{_ as __pageData,k as default};
