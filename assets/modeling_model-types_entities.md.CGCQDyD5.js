import{_ as e,c as a,o,a7 as t}from"./chunks/framework.BkavzUpE.js";const m=JSON.parse('{"title":"EF Entity Models","description":"","frontmatter":{},"headers":[],"relativePath":"modeling/model-types/entities.md","filePath":"modeling/model-types/entities.md"}'),n={name:"modeling/model-types/entities.md"},s=t(`<h1 id="ef-entity-models" tabindex="-1">EF Entity Models <a class="header-anchor" href="#ef-entity-models" aria-label="Permalink to &quot;EF Entity Models&quot;">​</a></h1><p>Models are the core business objects of your application - they serve as the fundamental representation of data in your application. The design of your models is very important. In <a href="https://docs.microsoft.com/en-us/ef/core/" target="_blank" rel="noreferrer">Entity Framework Core</a> (EF), data models are just Plain Old CLR Objects (POCOs).</p><h2 id="building-a-data-model" tabindex="-1">Building a Data Model <a class="header-anchor" href="#building-a-data-model" aria-label="Permalink to &quot;Building a Data Model&quot;">​</a></h2><p>To start building your data model that Coalesce will generate code for, follow the best practices for <a href="https://docs.microsoft.com/en-us/ef/core/" target="_blank" rel="noreferrer">EF Core</a>. Guidance on this topic is available in abundance in the <a href="https://docs.microsoft.com/en-us/ef/core/" target="_blank" rel="noreferrer">Entity Framework Core documentation</a>.</p><p>Don&#39;t worry about querying or saving data when you&#39;re just getting started - Coalesce will provide a lot of that functionality for you, and it is very easy to customize what Coalesce offers later. To get started, just build your entity classes and <code>DbContext</code> class. Annotate your <code>DbContext</code> class with <code>[Coalesce]</code> so that Coalesce will discover it and generate code based off of your context for you. Also ensure that each entity model has a <code>DbSet</code> property on the context - this is how Coalesce discovers your entity model types.</p><p>As you start building, you are highly encouraged to read the sections below. The linked pages explain in greater detail what Coalesce will build for you for each part of your data model.</p><h2 id="relational-modeling" tabindex="-1">Relational Modeling <a class="header-anchor" href="#relational-modeling" aria-label="Permalink to &quot;Relational Modeling&quot;">​</a></h2><h3 id="primary-keys" tabindex="-1">Primary Keys <a class="header-anchor" href="#primary-keys" aria-label="Permalink to &quot;Primary Keys&quot;">​</a></h3><p>To work with Coalesce, your model must have a single property for a primary key. By convention, this property should be named the same as your model class with <code>Id</code> appended to that name, but you can also annotate a property with <code>[Key]</code> or name it exactly &quot;Id&quot; to denote it as the primary key.</p><h3 id="foreign-keys-reference-navigation-properties" tabindex="-1">Foreign Keys &amp; Reference Navigation Properties <a class="header-anchor" href="#foreign-keys-reference-navigation-properties" aria-label="Permalink to &quot;Foreign Keys &amp; Reference Navigation Properties&quot;">​</a></h3><p>While a foreign key may be defined in EF via <code>DbContext.OnModelCreating</code> or similar methods, Coalesce won&#39;t know that a property is a foreign key unless it is accompanied by a corresponding reference navigation property, and vice versa - Coalesce cannot examine your EF model metadata at generation time - it can only see the API surface of your C# code.</p><p>In cases where the foreign key is not named after the navigation property with <code>&quot;Id&quot;</code> appended, the <code>[ForeignKeyAttribute]</code> may be used on either the key or the navigation property to denote the other property of the pair, in accordance with the recommendations set forth by <a href="https://learn.microsoft.com/en-us/ef/core/modeling/relationships/mapping-attributes#foreignkeyattribute" target="_blank" rel="noreferrer">EF Core&#39;s Modeling Guidelines</a>.</p><h3 id="collection-navigation-properties" tabindex="-1">Collection Navigation Properties <a class="header-anchor" href="#collection-navigation-properties" aria-label="Permalink to &quot;Collection Navigation Properties&quot;">​</a></h3><p>On entities that are the &quot;one&quot; side of a one-to-many relationship, collection navigation properties can be defined and used in the typical manner. In the event where the inverse property on the other side of the relationship cannot be determined, <code>[InversePropertyAttribute]</code> will need to be used. <a href="https://learn.microsoft.com/en-us/ef/core/modeling/relationships/mapping-attributes#inversepropertyattribute" target="_blank" rel="noreferrer">EF Core provides documentation</a> on how to use this attribute. Errors will be displayed at generation time if an inverse property cannot be determined without the attribute.</p><h3 id="one-to-one-relationships" tabindex="-1">One-to-one Relationships <a class="header-anchor" href="#one-to-one-relationships" aria-label="Permalink to &quot;One-to-one Relationships&quot;">​</a></h3><p>One-to-one relationships can be represented in Coalesce, but require fairly specific configuration to satisfy both EF and Coalesce&#39;s needs. Specifically, the dependent/child side of the one-to-one (the entity whose PK is also a FK), must explicitly annotate its PK with <code>[ForeignKey]</code> pointing at the parent navigation property. For example:</p><div class="language-c#"><button title="Copy Code" class="copy"></button><span class="lang">c#</span><pre class="shiki dark-plus vp-code"><code><span class="line"><span style="color:#569CD6;">public</span><span style="color:#569CD6;"> class</span><span style="color:#4EC9B0;"> OneToOneParent</span></span>
<span class="line"><span style="color:#D4D4D4;">{</span></span>
<span class="line"><span style="color:#569CD6;">    public</span><span style="color:#569CD6;"> int</span><span style="color:#9CDCFE;"> Id</span><span style="color:#D4D4D4;"> { </span><span style="color:#569CD6;">get</span><span style="color:#D4D4D4;">; </span><span style="color:#569CD6;">set</span><span style="color:#D4D4D4;">; }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#569CD6;">    public</span><span style="color:#4EC9B0;"> OneToOneChild</span><span style="color:#D4D4D4;">? </span><span style="color:#9CDCFE;">Child</span><span style="color:#D4D4D4;"> { </span><span style="color:#569CD6;">get</span><span style="color:#D4D4D4;">; </span><span style="color:#569CD6;">set</span><span style="color:#D4D4D4;">; }</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#569CD6;">public</span><span style="color:#569CD6;"> class</span><span style="color:#4EC9B0;"> OneToOneChild</span></span>
<span class="line"><span style="color:#D4D4D4;">{</span></span>
<span class="line"><span style="color:#D4D4D4;">    [</span><span style="color:#4EC9B0;">Key</span><span style="color:#D4D4D4;">, </span><span style="color:#4EC9B0;">ForeignKey</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&quot;Parent&quot;</span><span style="color:#D4D4D4;">)]</span></span>
<span class="line"><span style="color:#569CD6;">    public</span><span style="color:#569CD6;"> int</span><span style="color:#9CDCFE;"> ParentId</span><span style="color:#D4D4D4;"> { </span><span style="color:#569CD6;">get</span><span style="color:#D4D4D4;">; </span><span style="color:#569CD6;">set</span><span style="color:#D4D4D4;">; }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#569CD6;">    public</span><span style="color:#4EC9B0;"> OneToOneParent</span><span style="color:#D4D4D4;">? </span><span style="color:#9CDCFE;">Parent</span><span style="color:#D4D4D4;"> { </span><span style="color:#569CD6;">get</span><span style="color:#D4D4D4;">; </span><span style="color:#569CD6;">set</span><span style="color:#D4D4D4;">; }</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span></code></pre></div><p>Alternatively, you could also implement a one-to-one like a normal many-to-many relationship, where both sides of the relationship have their own distinct PK, and just never add more than one child to any particular principal entity. A unique constraint on the foreign key column can enforce the singularity of this relationship.</p><h3 id="inheritance-tph-and-tpt" tabindex="-1">Inheritance (TPH and TPT) <a class="header-anchor" href="#inheritance-tph-and-tpt" aria-label="Permalink to &quot;Inheritance (TPH and TPT)&quot;">​</a></h3><p>Coalesce is compatible with TPH, TPT, and TPCT entity hierarchies. Define your models as you normally would per <a href="https://learn.microsoft.com/en-us/ef/core/modeling/inheritance" target="_blank" rel="noreferrer">the EF documentation</a>. Coalesce can work with your hierarchy model, with the following notes and caveats:</p><ul><li>Abstract base classes are supported, and will be available for read via <code>/get</code>, <code>/list</code>, and <code>/count</code> endpoints if they have a public <code>DbSet</code> property on the <code>DbContext</code> and are not disabled via <a href="/Coalesce/topics/security.html#endpoint-security">attributes</a>. Abstract base classes also support <a href="/Coalesce/modeling/model-components/methods.html">Custom Methods</a> without issue. Modification actions (save/delete) on abstract base types are not supported. The responses from <code>/get</code> and <code>/list</code> on the abstract base will be serialized as the DTO type for the abstract base class without any polymorphism, meaning that these API responses will not include any &quot;extra&quot; properties that are defined on the concrete types for these entities. If you need properties from the concrete types, query those directly from their own API endpoints, or define abstract getter properties on the base type that are implemented on each concrete type.</li><li>The polymorphism / inheritance hierarchy of your C# models will not be reflected in the generated <a href="/Coalesce/stacks/vue/layers/viewmodels.html">TypeScript ViewModels</a>. However, since TypeScript types are structural, as opposed to C#&#39;s nominal types, you can easily use your types polymorphically when working with the <a href="/Coalesce/stacks/vue/layers/models.html">Model Layer</a>, or use union types when working with the ViewModels.</li><li>If you want to expose the discriminator property to the client, map it to a .NET property on the base type <a href="https://learn.microsoft.com/en-us/ef/core/modeling/inheritance#table-per-hierarchy-and-discriminator-configuration" target="_blank" rel="noreferrer">per EF documentation</a>.</li></ul><h2 id="other-model-customization" tabindex="-1">Other Model Customization <a class="header-anchor" href="#other-model-customization" aria-label="Permalink to &quot;Other Model Customization&quot;">​</a></h2><h3 id="properties" tabindex="-1">Properties <a class="header-anchor" href="#properties" aria-label="Permalink to &quot;Properties&quot;">​</a></h3><p>Read <a href="/Coalesce/modeling/model-components/properties.html">Properties</a> for an outline of the different types of properties that you may place on your models and the code that Coalesce will generate for each of them. The above section also details the specific needs of properties that have a relational role in your model.</p><h3 id="attributes" tabindex="-1">Attributes <a class="header-anchor" href="#attributes" aria-label="Permalink to &quot;Attributes&quot;">​</a></h3><p>Coalesce provides a number of C# attributes that can be used to decorate your model classes and their properties in order to customize behavior, appearance, security, and more. Coalesce also supports a number of annotations from <code>System.ComponentModel.DataAnnotations</code>.</p><p>Read <a href="/Coalesce/modeling/model-components/attributes.html">Attributes</a> to learn more.</p><h3 id="methods" tabindex="-1">Methods <a class="header-anchor" href="#methods" aria-label="Permalink to &quot;Methods&quot;">​</a></h3><p>You can place both static and interface methods on your model classes. Any public methods annotated with <a href="/Coalesce/modeling/model-components/attributes/coalesce.html">[Coalesce]</a> will have a generated API endpoint and corresponding generated TypeScript members for calling this API endpoint. Read <a href="/Coalesce/modeling/model-components/methods.html">Methods</a> to learn more.</p><h2 id="customizing-crud-operations" tabindex="-1">Customizing CRUD Operations <a class="header-anchor" href="#customizing-crud-operations" aria-label="Permalink to &quot;Customizing CRUD Operations&quot;">​</a></h2><p>Once you&#39;ve got a solid data model in place, its time to start customizing the way that Coalesce will <em>read</em> your data, as well as the way that it will handle your data when processing <em>creates</em>, <em>updates</em>, and <em>deletes</em>.</p><h3 id="data-sources" tabindex="-1">Data Sources <a class="header-anchor" href="#data-sources" aria-label="Permalink to &quot;Data Sources&quot;">​</a></h3><p>The method by which you can control what data the users of your application can access through Coalesce&#39;s generated APIs is by creating custom data sources. These are classes that allow complete control over the way that data is retrieved from your database and provided to clients. Read <a href="/Coalesce/modeling/model-components/data-sources.html">Data Sources</a> to learn more.</p><h3 id="behaviors" tabindex="-1">Behaviors <a class="header-anchor" href="#behaviors" aria-label="Permalink to &quot;Behaviors&quot;">​</a></h3><p>Behaviors in Coalesce are to mutating data as data sources are to reading data. Defining a behaviors class for a model allows complete control over the way that Coalesce will create, update, and delete your application&#39;s data in response to requests made through its generated API. Read <a href="/Coalesce/modeling/model-components/behaviors.html">Behaviors</a> to learn more.</p>`,35),r=[s];function i(l,c,p,d,h,u){return o(),a("div",null,r)}const f=e(n,[["render",i]]);export{m as __pageData,f as default};
