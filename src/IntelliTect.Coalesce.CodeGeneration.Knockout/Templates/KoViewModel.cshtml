@using IntelliTect.Coalesce.CodeGeneration.Templating.Razor;
@using IntelliTect.Coalesce.CodeGeneration.Knockout.Generators;
@using IntelliTect.Coalesce.TypeDefinition
@using IntelliTect.Coalesce.Knockout.TypeDefinition
@using IntelliTect.Coalesce.Utilities
@inherits CoalesceTemplate<KoViewModel>
@{
    ClassViewModel model = Model.Model;
    string moduleName = "ViewModels";
    string listModuleName = "ListViewModels";
    if (!string.IsNullOrWhiteSpace(Model.AreaName))
    {
        moduleName = Model.AreaName + "." + moduleName;
        listModuleName = Model.AreaName + "." + listModuleName;
    }
    if (!string.IsNullOrWhiteSpace(Model.ModulePrefix))
    {
        moduleName = Model.ModulePrefix + "." + moduleName;
    }
}

/// <reference path="../coalesce.dependencies.d.ts" />

// Knockout View Model for: @(model.Name)
// Generated by IntelliTect.Coalesce

module @moduleName {

	export class @(model.ViewModelGeneratedClassName) extends Coalesce.BaseViewModel
    {
        public readonly modelName = "@(model.Name)";
        public readonly primaryKeyName: keyof this = "@(model.PrimaryKey.JsVariable)";
        public readonly modelDisplayName = "@(model.DisplayName)";
        public readonly apiController = "/@(model.ApiRouteControllerPart)";
        public readonly viewController = "/@(model.ControllerName)";

        /** Behavioral configuration for all instances of @(model.ViewModelClassName). Can be overidden on each instance via instance.coalesceConfig. */
        public static coalesceConfig: Coalesce.ViewModelConfiguration<@(model.ViewModelClassName)>
            = new Coalesce.ViewModelConfiguration<@(model.ViewModelClassName)>(Coalesce.GlobalConfiguration.viewModel);

        /** Behavioral configuration for the current @(model.ViewModelClassName) instance. */
        public coalesceConfig: Coalesce.ViewModelConfiguration<this>
            = new Coalesce.ViewModelConfiguration<@(model.ViewModelGeneratedClassName)>(@(model.ViewModelClassName).coalesceConfig);
    
        /** 
            The namespace containing all possible values of this.dataSource.
        */
        public dataSources: typeof ListViewModels.@(model.Name)DataSources = ListViewModels.@(model.Name)DataSources;
    

        @foreach (PropertyViewModel prop in model.ClientProperties)
        {
        if (prop.Comment.Length > 0)
        {
        @:/** @(prop.Comment) */
        }
        @:public @(prop.JsVariable): @(prop.Type.TsKnockoutType()) = @(prop.Type.ObservableConstructorCall());
        if (prop.PureType.IsEnum)
        {
        @:/** Text value for enumeration @prop.Name */
        @:public @(prop.JsTextPropertyName): KnockoutComputed<string> = ko.pureComputed(() => {
            @:for(var i = 0; i < this.@(prop.JsVariable)Values.length; i++){
                @:if (this.@(prop.JsVariable)Values[i].id == this.@(prop.JsVariable)()){
                    @:return this.@(prop.JsVariable)Values[i].value;
                @:}
            @:}
        @:});
        }
        if (prop.IsManytoManyCollection)
        {
        if (prop.Comment.Length > 0)
        {
        @:/** Collection of related objects for many-to-many relationship @prop.ManyToManyCollectionName via @prop.Name */
        }
        @:public @(prop.ManyToManyCollectionName.ToCamelCase()): KnockoutObservableArray<ViewModels.@(prop.ManyToManyCollectionProperty.Object.ViewModelClassName)> = ko.observableArray([]);
        }
        }

       
        @foreach (PropertyViewModel prop in model.ClientProperties.Where(f => f.IsPOCO))
        {
        @:/** Display text for @(prop.Name) */
        @:public @prop.JsTextPropertyName: KnockoutComputed<string>;
        }
        
        @foreach (PropertyViewModel prop in model.ClientProperties.Where(f => f.Type.IsCollection && !f.IsManytoManyCollection && f.PureTypeOnContext))
        {
        <text>
        /** Add object to @(prop.JsVariable) */
        public addTo@(prop.Name) = (autoSave?: boolean | null): @prop.PureType.ClassViewModel.Name => {
            var newItem = new @(prop.Object.ViewModelClassName)();
            if (typeof(autoSave) == 'boolean'){
                newItem.coalesceConfig.autoSaveEnabled(autoSave);
            }
            newItem.parent = this;
            newItem.parentCollection = this.@prop.JsVariable;
            newItem.isExpanded(true);
            @if (prop.HasInverseProperty)
            {
            @:newItem.@(prop.InverseIdProperty.JsVariable)(this.@(model.PrimaryKey.JsVariable)());
            }
            else if (prop.Object.PropertyByName(model.PrimaryKey.JsVariable) != null)
            {
            @:newItem.@(model.PrimaryKey.JsVariable)(this.@(model.PrimaryKey.JsVariable)());
            }
            this.@(prop.JsVariable).push(newItem);
            return newItem;
        };

        /** ListViewModel for @(prop.Name). Allows for loading subsets of data. */
        public @(prop.JsVariable)List: (loadImmediate?: boolean) => @(listModuleName).@(prop.Object.ListViewModelClassName);
        </text>
        }

        @foreach (PropertyViewModel prop in model.ClientProperties.Where(f => f.Type.IsCollection && f.PureTypeOnContext))
        {
        @:/** Url for a table view of all members of collection @prop.Name for the current object. */
        @:public @(prop.ListEditorUrlName): KnockoutComputed<string> = ko.computed(
            if (prop.ListEditorUrl == null)
            {
            @:() => "Inverse property not set on @(model.Name) for property @(prop.Name)",
            }
            else
            {
            @:() => this.coalesceConfig.baseViewUrl() + '/@(prop.ListEditorUrl)' + this.@(model.PrimaryKey.JsVariable)(),
            }
            @:null, { deferEvaluation: true }
        @:);
        }

        @foreach (PropertyViewModel prop in model.ClientProperties.Where(f => f.IsPOCO && !f.Type.IsCollection))
        {
        @:/** Pops up a stock editor for object @prop.JsVariable */
        @:public show@(prop.Name)Editor: (callback?: any) => void;
        }


        @foreach (PropertyViewModel prop in model.ClientProperties.Where(f => f.PureType.IsEnum))
        {
        @:/** Array of all possible names & values of enum @prop.JsVariable */
        @:public @(prop.JsVariable)Values: EnumValue[] = [ 
        @foreach (var kvp in prop.Type.EnumValues)
        {
            @:{ id: @kvp.Key, value: '@kvp.Value.ToProperCase()' },
        }
        @:];
        }

        @foreach (var method in model.ClientMethods.Where(m => !m.IsStatic || m.ReturnType.EqualsType(model.Type)))
        {
            <text>
        public static @(method.Name.ToPascalCase()) = class @(method.Name.ToPascalCase()) extends Coalesce.ClientMethod<@(model.ViewModelGeneratedClassName), @(method.ReturnType.TsType)> {
            public readonly name = "Rename";
			public readonly verb = "@(method.ApiActionHttpMethod)";

            public result: KnockoutObservable<Person> = ko.observable(null);
    
            /** Calls server method (@method.Name) with the given arguments */
            public invoke = (@method.TsParameters): JQueryPromise<any> => {
                return this.invokeWithData(@method.JsPostObject, callback, reload);
            };
    
            @if (method.ClientParameters.Any())
            {
                
            @:public static Args = class Args {
                @foreach (var arg in method.ClientParameters)
                {
                @:public @(arg.CsArgumentName): @(arg.Type.TsKnockoutType()) = @(arg.Type.ObservableConstructorCall());
                }
            @:}
            @:/** Calls server method (@method.Name) with an instance of @(method.Name.ToPascalCase()).Args, or the value of this.args if not specified. */
            // We can't explicitly declare the type of the args parameter here - TypeScript doesn't allow it. Thankfully, we can implicitly type using the default.
            @:public invokeWithArgs = (args = this.args, callback?: (result: @method.ReturnType.TsType) => void, reload: boolean = true) => {
                @:return this.invoke(@(method.JsArguments("args", true)), reload);
            @:}
            @:/** Object that can be easily bound to fields to allow data entry for the method */
            @:public args = new @(method.Name.ToPascalCase()).Args(); 
            }

            protected loadResponse = (data: any, callback?: (result: @method.ReturnType.TsType) => void, reload?: boolean) => {
            @if (method.ReturnType.IsCollection && method.ReturnType.PureType.HasClassViewModel)
            {
                var keyNameArg = method.ReturnType.PureType.ClassViewModel.PrimaryKey != null
                    ? $"'{method.ReturnType.PureType.ClassViewModel.PrimaryKey.JsVariable}'"
                    : "null";
                @:Coalesce.KnockoutUtilities.RebuildArray(this.result, data, @keyNameArg, ViewModels.@method.ReturnType.PureType.ClassViewModel.Name, this, true);
            }
            else if (method.ReturnType.HasClassViewModel)
            {
                @:if (!this.result()){
                    @:this.result(new @(method.ReturnType.ClassViewModel.ViewModelClassName)(data));
                @:} else {
                    @:this.result().loadFromDto(data);
                @:}
            }
            else
            {
                @:this.result(data);
            }

            @if (method.ReturnType.EqualsType(method.Parent.Type))
            {
                @:// The return type is the type of the object, load it.
                @:this.parent.loadFromDto(data, true)
                @:if (typeof(callback) == "function") {
                    @:var result = this.result();
                    @:callback(result);
                @:}
            }
            else
            {
                @:if (typeof(callback) != "function") return;
                @:var result = this.result();
                @:if (reload) {
                @:  this.parent.load(null, () => callback(result));
                @:} else {
                @:  callback(result);
                @:}
            }
            };
        };
    
        /**
            Methods and properties for invoking server method @method.Name.
        @if (method.Comment.Length > 0)
        {
        @:    @(method.Comment)
        }
        */
        public @(method.JsVariable) = new @(model.ViewModelClassName).@(method.Name.ToPascalCase())(this);
            </text>
        
        @:
        }

        /** 
            Load the ViewModel object from the DTO. 
            @@param force: Will override the check against isLoading that is done to prevent recursion. False is default.
            @@param allowCollectionDeletes: Set true when entire collections are loaded. True is the default. In some cases only a partial collection is returned, set to false to only add/update collections.
        */
        public loadFromDto = (data: any, force: boolean = false, allowCollectionDeletes: boolean = true): void => {
            if (!data || (!force && this.isLoading())) return;
            this.isLoading(true);
            // Set the ID 
            this.myId = data.@(model.PrimaryKey.JsonName);
            this.@(model.PrimaryKey.JsVariable)(data.@(model.PrimaryKey.JsonName));
            // Load the lists of other objects
        @foreach (PropertyViewModel prop in model.ClientProperties.Where(p=>p.Type.IsCollection))
        { 
            @:if (data.@prop.JsonName != null) {
            @if (prop.Object.PrimaryKey != null)
            {
                @:// Merge the incoming array
                @:Coalesce.KnockoutUtilities.RebuildArray(this.@prop.JsVariable, data.@prop.JsonName, '@prop.Object.PrimaryKey.JsonName', @prop.Object.ViewModelClassName, this, allowCollectionDeletes);
                if (prop.IsManytoManyCollection)
                {
                @:// Add many-to-many collection
                @:let objs: any[] = [];
                @:$.each(data.@prop.JsonName, (index, item) => {
                    @:if (item.@prop.ManyToManyCollectionProperty.JsonName){
                        @:objs.push(item.@prop.ManyToManyCollectionProperty.JsonName);
                    @:}
                @:});
                @:Coalesce.KnockoutUtilities.RebuildArray(this.@(prop.ManyToManyCollectionName.ToCamelCase()), objs, '@prop.ManyToManyCollectionProperty.ObjectIdProperty.JsVariable', @prop.ManyToManyCollectionProperty.Object.ViewModelClassName, this, allowCollectionDeletes);
                }
            }
            else if (prop.PureType.IsPrimitive)
            {
                @:this.@(prop.JsVariable)(data.@prop.JsVariable);
            }
            else
            {
                @:Coalesce.KnockoutUtilities.RebuildArray(this.@prop.JsVariable, data.@prop.JsonName, null, @prop.Object.ViewModelClassName, this, allowCollectionDeletes);
            }
            @:} 
        }
            // Objects are loaded first so that they are available when the IDs get loaded.
            // This handles the issue with populating select lists with correct data because we now have the object.
            @foreach (PropertyViewModel prop in model.ClientProperties.Where(p => p.IsPOCO && !p.Type.IsCollection))
            {
            @:if (!data.@prop.JsonName) { 
                if (prop.ObjectIdProperty != null) {
                @:if (data.@prop.ObjectIdProperty.JsonName != this.@(prop.ObjectIdProperty.JsVariable)()) {
                    @:this.@(prop.JsVariable)(null);
                @:}
                }else{
                @:this.@(prop.JsVariable)(null);
                }
            @:} else {
                @:if (!this.@(prop.JsVariable)()){
                    @:this.@(prop.JsVariable)(new @(prop.Object.ViewModelClassName)(data.@prop.JsonName, this));
                @:} else {
                    @:this.@(prop.JsVariable)().loadFromDto(data.@prop.JsonName);
                @:}
                @if (prop.Object.OnContext) { 
                @:if (this.parent instanceof @(prop.Object.ViewModelClassName) && this.parent !== this.@(prop.JsVariable)() && this.parent.@(prop.Object.PrimaryKey.JsVariable)() == this.@(prop.JsVariable)().@(prop.Object.PrimaryKey.JsVariable)())
                @:{
                    @:this.parent.loadFromDto(data.@prop.JsonName, null, false);
                @:}
                }
            @:}
            }

            // The rest of the objects are loaded now.
            @foreach (PropertyViewModel prop in model.ClientProperties.Where(p => !p.HasValidValues && !p.Type.IsCollection))
            {
            if (prop.Type.IsDate)
            {   // Using valueOf/getTime here is a 20x performance increase over moment.isSame(). moment(new Date(...)) is also a 10x perf increase.
            @:if (data.@prop.JsonName == null) this.@(prop.JsVariable)(null);
            @:else if (this.@(prop.JsVariable)() == null || this.@(prop.JsVariable)().valueOf() != new Date(data.@prop.JsonName).getTime()){
                @:this.@(prop.JsVariable)(moment(new Date(data.@prop.JsonName)));
            @:}
            } else if (!prop.IsPOCO && !prop.IsPrimaryKey) {
            @:this.@(prop.JsVariable)(data.@prop.JsonName);
            }
            }
            if (this.coalesceConfig.onLoadFromDto()){
                this.coalesceConfig.onLoadFromDto()(this as any);
            }
            this.isLoading(false);
            this.isDirty(false);
    
            if (this.coalesceConfig.validateOnLoadFromDto()) this.validate();
        };
    
        /** Saves this object into a data transfer object to send to the server. */
        public saveToDto = (): any => {
            var dto: any = {};
            dto.@(model.PrimaryKey.JsonName) = this.@(model.PrimaryKey.JsVariable)();

            @foreach (PropertyViewModel prop in model.ClientProperties.Where(f => f.IsClientWritable && !f.IsPOCO ))
            {
                if (prop.Type.IsDate)
                {
            @:if (!this.@(prop.JsVariable)()) dto.@prop.JsonName = null;
            @:else dto.@prop.JsonName = this.@(prop.JsVariable)().format('YYYY-MM-DDTHH:mm:ss@(prop.Type.IsDateTimeOffset ? "ZZ" : "")');
            }
            else if (prop.IsForeignKey)
            {
            @:dto.@prop.JsonName = this.@(prop.JsVariable)();
            if (prop.IdPropertyObjectProperty != null && !prop.IsPrimaryKey)
            {
            // If the Id isn't set, use the object and see if that is set. Allows a child to get an Id after the fact. 
            @:if (!dto.@prop.JsonName && this.@(prop.IdPropertyObjectProperty.JsVariable)()) {
                @:dto.@prop.JsonName = this.@(prop.IdPropertyObjectProperty.JsVariable)().@(prop.IdPropertyObjectProperty.Object.PrimaryKey.JsVariable)();
            @:}
            }
            }
            else if (!prop.Type.IsCollection)
            {
            @:dto.@prop.JsonName = this.@(prop.JsVariable)();
            }
            }

            return dto;
        }
    
        /**
            Loads any child objects that have an ID set, but not the full object.
            This is useful when creating an object that has a parent object and the ID is set on the new child.
        */
        public loadChildren = (callback?: () => void): void => {
            var loadingCount = 0;
        @foreach (PropertyViewModel prop in model.ClientProperties.Where(f => f.IsPOCO && !f.Type.IsCollection && !f.IsReadOnly && !f.HasNotMapped))
        {
            @:// See if this.@(prop.JsVariable) needs to be loaded.
            @:if (this.@(prop.JsVariable)() == null && this.@(prop.ObjectIdProperty.JsVariable)() != null){
                @:loadingCount++;
                @:var @(prop.JsVariable)Obj = new @(prop.Object.ViewModelClassName)();
                @:@(prop.JsVariable)Obj.load(this.@(prop.ObjectIdProperty.JsVariable)(), () => {
                    @:loadingCount--;
                    @:this.@(prop.JsVariable)(@(prop.JsVariable)Obj);
                    @:if (loadingCount == 0 && typeof(callback) == "function"){
                        @:callback();
                    @:}
                @:});
            @:}
            }
            if (loadingCount == 0 && typeof(callback) == "function"){
                callback();
            }
        };
        
        public setupValidation = (): void => {
            if (this.errors !== null) return;
            this.errors = ko.validation.group([
            @foreach (PropertyViewModel prop in model.ClientProperties.Where(p => !p.ClientValidationAllowSave && !string.IsNullOrWhiteSpace(p.ClientValidationKnockoutJs())))
            {
                @:this.@(prop.JsVariable).extend({ @prop.ClientValidationKnockoutJs() }),
            }
            ]);
            this.warnings = ko.validation.group([
            @foreach (PropertyViewModel prop in model.ClientProperties.Where(p => p.ClientValidationAllowSave && !string.IsNullOrWhiteSpace(p.ClientValidationKnockoutJs())))
            {
                @:this.@(prop.JsVariable).extend({ @prop.ClientValidationKnockoutJs() }),
            }
            ]);
        }
    
        // Computed Observable for edit URL
        public editUrl: KnockoutComputed<string> = ko.pureComputed(() => {
            return this.coalesceConfig.baseViewUrl() + this.viewController + "/CreateEdit?id=" + this.@(model.PrimaryKey.JsVariable)();
        });

        constructor(newItem?: object, parent?: Coalesce.BaseViewModel | @(listModuleName).@(model.ListViewModelClassName)){
            super(parent);
            this.baseInitialize();
            var self = this;
            self.myId;

            // Create computeds for display for objects
            @foreach (PropertyViewModel prop in model.ClientProperties.Where(f => f.IsPOCO))
            {
			@:self.@prop.JsTextPropertyName = ko.pureComputed(function()
			@:{   // If the object exists, use the text value. Otherwise show 'None'
				@:if (self.@(prop.JsVariable)() && self.@(prop.JsVariable)().@(prop.Object.ListTextProperty.JsVariable)()) {
					@:return self.@(prop.JsVariable)().@(prop.Object.ListTextProperty.JsVariable)().toString();
				@:} else {
					@:return "None";
				@:}
			@:});
            }

    
            @foreach (PropertyViewModel prop in model.ClientProperties.Where(f => f.Type.IsCollection && !f.IsManytoManyCollection && f.PureTypeOnContext))
            {
            @:// List Object model for @(prop.Name). Allows for loading subsets of data.
            @:var _@(prop.JsVariable)List: @(listModuleName).@(prop.Object.ListViewModelClassName) = null;
            @:self.@(prop.JsVariable)List = function(loadImmediate = true) {
                @:if (!_@(prop.JsVariable)List){
                    @:_@(prop.JsVariable)List = new @(listModuleName).@(prop.Object.ListViewModelClassName)();
                    @:if (loadImmediate) load@(prop.Name)List();
                    @:self.@(prop.Parent.PrimaryKey.JsVariable).subscribe(load@(prop.Name)List)
                @:}
                @:return _@(prop.JsVariable)List;
            @:}

            @:function load@(prop.Name)List() {
                @:if (self.@(prop.Parent.PrimaryKey.JsVariable)()){
                    if (prop.InverseIdProperty != null)
                    {
                    @:_@(prop.JsVariable)List.queryString = "filter.@(prop.InverseIdProperty.Name)=" + self.@(prop.Parent.PrimaryKey.JsVariable)();
                    }
                    else {
                    @:_@(prop.JsVariable)List.queryString = "filter.@(model.PrimaryKey.Name)=" + self.@(prop.Parent.PrimaryKey.JsVariable)();
                    }
                    @:_@(prop.JsVariable)List.load();
                @:}
            @:}
            }


            @foreach (PropertyViewModel prop in model.ClientProperties.Where(f => f.IsPOCO && !f.Type.IsCollection && f.PureType.ClassViewModel.HasDbSet))
            {
            @:self.show@(prop.Name)Editor = function(callback: any) {
                @:if (!self.@(prop.JsVariable)()) {
                    @:self.@(prop.JsVariable)(new @(prop.Object.ViewModelClassName)());
                @:}
                @:self.@(prop.JsVariable)().showEditor(callback)
            @:};
            }

            // This stuff needs to be done after everything else is set up.
        @foreach (PropertyViewModel prop in model.ClientProperties.Where(p=>p.IsClientWritable && !p.IsManytoManyCollection && !p.Type.IsCollection))
        {
            @:self.@(prop.JsVariable).subscribe(self.autoSave);
        }
        @foreach (PropertyViewModel prop in model.ClientProperties.Where(p => p.IsManytoManyCollection))
        {
            <text>
            self.@(prop.ManyToManyCollectionName.ToCamelCase()).subscribe<KnockoutArrayChange<@prop.ManyToManyCollectionProperty.Object.ViewModelClassName>[]>(changes => {
                for (var i in changes){
                    var change = changes[i];
                    self.autoSaveCollection(
                        change.status, 
                        this.@prop.JsVariable, 
                        @prop.Object.ViewModelClassName, 
                        '@prop.Object.ClientProperties.First(f => f.Type.EqualsType(model.Type)).ObjectIdProperty.JsVariable',
                        '@prop.ManyToManyCollectionProperty.ObjectIdProperty.JsVariable',
                        change.value.@(prop.ManyToManyCollectionProperty.Object.PrimaryKey.JsVariable)()
                    );
                }
            }, null, "arrayChange");
            </text>
        }

            if (newItem) {
                self.loadFromDto(newItem, true);
            }
        }
    }





    export namespace @(model.ViewModelGeneratedClassName) {
        @foreach (PropertyViewModel prop in model.ClientProperties.Where(f => f.PureType.IsEnum))
        {
        @:export enum @(prop.Name)Enum {
        @foreach (var kvp in prop.Type.EnumValues)
        {
            @:@kvp.Value = @kvp.Key,
        }
        @:};
        }
    }
}